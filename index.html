<script>
  const yesBtn = document.getElementById('yesBtn');
  const noBtn = document.getElementById('noBtn');
  const result = document.getElementById('result');
  const rain = document.getElementById('rain');

  function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

  // âœ… MODIFIED: Start "No" right next to "Yes" (same row, centered)
  function placeNoNearYes() {
    const gap = 14;      // space between Yes and No
    const padding = 12;  // keep inside viewport

    const y = yesBtn.getBoundingClientRect();

    // Measure "No" size reliably (even if not fully laid out yet)
    const w = noBtn.offsetWidth || 120;
    const h = noBtn.offsetHeight || 44;

    // Start to the RIGHT of the Yes button (same vertical center)
    let x = y.right + gap;
    let top = y.top + (y.height - h) / 2;

    // Keep inside viewport
    const vw = window.innerWidth;
    const vh = window.innerHeight;

    // If right side overflows, start to the LEFT of Yes
    if (x + w + padding > vw) {
      x = y.left - w - gap;
    }

    // If still overflow (tiny screens), put it BELOW Yes
    if (x < padding) {
      x = y.left;
      top = y.bottom + gap;
    }

    x = clamp(x, padding, vw - w - padding);
    top = clamp(top, padding, vh - h - padding);

    noBtn.style.left = `${x}px`;
    noBtn.style.top = `${top}px`;
    noBtn.style.transform = `translate(0, 0)`;
  }

  // Run away position (anywhere)
  function randomPositionForNo() {
    const padding = 14;
    const vw = window.innerWidth;
    const vh = window.innerHeight;

    const rect = noBtn.getBoundingClientRect();
    const w = rect.width || 120;
    const h = rect.height || 44;

    let x = padding + Math.random() * (vw - w - padding * 2);
    let y = padding + Math.random() * (vh - h - padding * 2);

    noBtn.style.left = `${x}px`;
    noBtn.style.top = `${y}px`;
    noBtn.style.transform = `translate(0, 0)`;
  }

  const flee = () => randomPositionForNo();

  window.addEventListener('load', () => {
    noBtn.classList.add('disabled'); // keep unclickable
    placeNoNearYes();                // âœ… start near Yes
  });

  window.addEventListener('resize', () => {
    placeNoNearYes(); // keep it near Yes after resize
  });

  document.addEventListener('mousemove', (e) => {
    const r = noBtn.getBoundingClientRect();
    const cx = r.left + r.width / 2;
    const cy = r.top + r.height / 2;
    const dist = Math.hypot(e.clientX - cx, e.clientY - cy);
    if (dist < 140) flee();
  });

  document.addEventListener('touchstart', (e) => {
    const t = e.touches[0];
    const r = noBtn.getBoundingClientRect();
    const near =
      t.clientX >= r.left - 80 && t.clientX <= r.right + 80 &&
      t.clientY >= r.top - 80 && t.clientY <= r.bottom + 80;
    if (near) flee();
  }, { passive: true });

  yesBtn.addEventListener('click', () => {
    result.classList.add('show');
    noBtn.style.display = 'none';
    startEmojiRain();
    document.querySelector('h1').textContent = "YAY!! ğŸ’";
    document.querySelector('p').textContent = "Best choice ever ğŸ˜˜";
  });

  function startEmojiRain() {
    rain.classList.add('show');
    const emojis = ["ğŸ’–","ğŸ’˜","ğŸ’—","ğŸ’","ğŸ’•","ğŸ¥°","ğŸ˜˜","ğŸ˜","ğŸŒ¸"];
    for (let i = 0; i < 40; i++) {
      const span = document.createElement('span');
      span.className = 'heart';
      span.textContent = emojis[Math.floor(Math.random() * emojis.length)];
      span.style.left = (Math.random() * 100) + "vw";
      span.style.animationDuration = (2.5 + Math.random() * 2.5) + "s";
      span.style.animationDelay = (Math.random() * 0.8) + "s";
      span.style.fontSize = (18 + Math.random() * 18) + "px";
      rain.appendChild(span);
      const dur = parseFloat(span.style.animationDuration);
      const del = parseFloat(span.style.animationDelay);
      setTimeout(() => span.remove(), (dur + del) * 1000 + 200);
    }
  }
</script>
